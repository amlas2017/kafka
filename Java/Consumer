import org.apache.kafka.clients.consumer.ConsumerRecord;
import org.apache.kafka.clients.consumer.ConsumerRecords;
import org.apache.kafka.clients.consumer.KafkaConsumer;

import java.util.Arrays;
import java.util.Properties;

public class SimpleConsumer {

    public static void main(String[] args) throws Exception {
      //  if(args.length == 0){
      //      System.out.println("Entrer le nom du topic");
      //      return;

        //String topicName = args[0].toString();
        String topicName =  "my-topic";
        Properties props = new Properties();

        props.put("bootstrap.servers", "poste3:9092");
        props.put("group.id", "test");
        props.put("enable.auto.commit", "true");
        props.put("auto.commit.interval.ms", "1000");
        props.put("session.timeout.ms", "30000");
        props.put("key.deserializer", "org.apache.kafka.common.serialization.StringDeserializer");
        props.put("value.deserializer", "org.apache.kafka.common.serialization.StringDeserializer");

        KafkaConsumer<String, String> consumer = new KafkaConsumer<String, String>(props);

        // Kafka Consumer va souscrire a la liste de topics ici
        consumer.subscribe(Arrays.asList(topicName));

        // Afficher le nom du topic
        System.out.println("Souscris au topic " + topicName);
        int i = 0;

        while (true) {
            ConsumerRecords<String, String> records = consumer.poll(100);  // cette ligne est la plus importante dans Kafka Consumer
            
/* De la même manière que les requins doivent continuer à bouger ou ils meurent, les consommateurs doivent continuer à sonder Kafka ou ils seront considérés comme 
morts et les partitions qu'ils consomment seront remises à un autre consommateur du groupe pour continuer à consommer.
Le paramètre que nous passons, poll(), est un intervalle de temporisation et contrôle la durée pendant laquelle poll() bloquera si les données ne sont pas 
disponibles dans le tampon consommateur. S'il est défini sur 0, poll() retournera immédiatement ; sinon, il attendra le nombre de millisecondes spécifié pour 
que les données arrivent du courtier.*/                   
                  
         
            for (ConsumerRecord<String, String> record : records)

                // Afficher l'offset, clef et valeur des enregistrements du consommateur
                System.out.printf("offset = %d, key = %s, value = %s\n", record.offset(), record.key(), record.value());  
                // on peut récupérer plus d'éléments comme record.partition...
        }
    }
}

*******************************************************************************************************************************************************
 ConsumerRecords<String, String> records = consumer.poll(Duration.ofSeconds(5));
          for (ConsumerRecord<String, String> record : records) {
              System.out.printf("consumed: key = %s, value = %s, partition id= %s, offset = %s%n",
                      record.key(), record.value(), record.partition(), record.offset());
          }
          if (records.isEmpty()) {
              System.out.println("-- terminating consumer --");   // <------------------        pour savoir que le consumer s'est arrété.
              break;
          }
